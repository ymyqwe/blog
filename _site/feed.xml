<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>鱼头的博客</title>
    <description>鱼头的小博客。随便写的，随便看看吧。</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 07 Feb 2017 10:59:53 +0800</pubDate>
    <lastBuildDate>Tue, 07 Feb 2017 10:59:53 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>使用Npm, Webpack开发React应用</title>
        <description>&lt;p&gt;通过React，Facebook确确实实改变了我们对于前端开发UI组件的思路。尽管React的学习路线并不陡峭，但是对于初学者来说，它的一些工具(&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;，&lt;a href=&quot;https://webpack.github.io/docs/&quot;&gt;Webpack&lt;/a&gt;)和类库却是一个难点。&lt;/p&gt;

&lt;p&gt;尽管这些工具对于React并不是必须的，但是为充分利用&lt;a href=&quot;http://es6-features.org/#Constants&quot;&gt;ES6&lt;/a&gt;，&lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX&lt;/a&gt;和打包的精髓，我们需要它们。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;目录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#webpack&quot;&gt;安装、配置Webpack&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#babel-loader&quot;&gt;设置Babel-Loader&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hello-react&quot;&gt;Hello React&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#webpack-1&quot;&gt;便捷化使用webpack&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;webpack&quot;&gt;安装、配置Webpack&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://webpack.github.io/docs/&quot;&gt;Webpack&lt;/a&gt;是一个模块打包工具，它可以通过固定配置将模块依赖打包成静态文件。Webpack支持&lt;a href=&quot;http://webpack.github.io/docs/loaders.html&quot;&gt;加载器&lt;/a&gt;，这对于React来说简直是一个完美的工具。&lt;/p&gt;

&lt;p&gt;首先，进入项目文件，安装webpack(请先安装node、npm)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i webpack -S
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用Webpack的最佳方法是通过一个配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt;来开展工作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;touch webpack.config.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更新配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var webpack = require(&#39;webpack&#39;);
var path = require(&#39;path&#39;);

var BUILD_DIR = path.resolve(__dirname, &#39;src/client/public&#39;);
var APP_DIR = path.resolve(__dirname, &#39;src/client/app&#39;);

var config = {
  entry: APP_DIR + &#39;/index.jsx&#39;,
  output: {
    path: BUILD_DIR,
    filename: &#39;bundle.js&#39;
  }
};

module.exports = config;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;APP_DIR&lt;/code&gt;是React应用的目录路径，&lt;code class=&quot;highlighter-rouge&quot;&gt;BUILD_DIR&lt;/code&gt;则是打包文件的输出路径。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config&lt;/code&gt;对象中，&lt;i&gt;entry&lt;/i&gt;表示入口文件，Webpack也支持多入口文件，&lt;i&gt;src/client/app&lt;/i&gt; 目录下的 &lt;i&gt;index.js&lt;/i&gt; 就是应用的入口文件。&lt;i&gt;output&lt;/i&gt; 则表示打包过程完成之后Webpack需要作的输出。这里我们会创建 &lt;i&gt;bundle.js&lt;/i&gt; 到 &lt;i&gt;src/client/public&lt;/i&gt;。&lt;/p&gt;

&lt;p&gt;接下来，在 &lt;i&gt;./src/client/app&lt;/i&gt;中创建 &lt;i&gt;index.js&lt;/i&gt;文件，添加如下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(&#39;Hello World!&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在终端中运行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack -d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码通过开发者模式运行webpack并且在 &lt;i&gt;src/client/public&lt;/i&gt;中打包生成了 &lt;i&gt;bundle.js&lt;/i&gt;文件和关联的 &lt;i&gt;bundle.js.map&lt;/i&gt;文件。&lt;/p&gt;

&lt;p&gt;随后，在 &lt;i&gt;src/client&lt;/i&gt;目录下创建 &lt;i&gt;index.html&lt;/i&gt;文件，并引入 &lt;i&gt;bundle.js&lt;/i&gt;文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;React Test&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;app&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;public/bundle.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果此时你打开浏览器，在console log中就可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World!&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;babel-loader&quot;&gt;设置Babel-Loader&lt;/h3&gt;

&lt;p&gt;React在使用JSX和ES6的时候是更有效率的，但是JSX语法和ES6并不是在所有浏览器种都支持的。因此，我们需要一个语法转换器，这时候就需要balel了。&lt;/p&gt;

&lt;p&gt;首先安装如下npm包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i babel-loader babel-preset-es-2015 babel-preset-react -S
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i&gt;babel-preset-es2015&lt;/i&gt;用于翻译ES6，&lt;i&gt;babel-preset-react&lt;/i&gt;则用于翻译JSX语法。与webpack一样，&lt;i&gt;babel-loader&lt;/i&gt;也需要配置文件，这边我们需要告诉他使用ES6，JSX插件。&lt;/p&gt;

&lt;p&gt;创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;touch .babelrc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;作如下修改&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;presets&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;es2015&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下一步是告诉webpack打包时使用babel-loader，打开 &lt;i&gt;webpack.config.js&lt;/i&gt;并作如下更新&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//  ...
var config = {
    //  ...
    module : {
        loaders : [
            {
                test : /\.js$/,
                include : APP_DIR,
                loader : &#39;babel-loader&#39;
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i&gt;loaders&lt;/i&gt;属性接受作为数组的加载器，此处我们使用了 &lt;i&gt;babel-loader&lt;/i&gt;。 每个 &lt;i&gt;loader&lt;/i&gt;属性需要通过 &lt;i&gt;test&lt;/i&gt;属性指定文件扩展。这里我们用正则表达式同时指定了 &lt;i&gt;.js&lt;/i&gt;和 &lt;i&gt;.jsx&lt;/i&gt;文件。&lt;i&gt;include&lt;/i&gt;属性则指定了查找这些文件扩展的目录。&lt;i&gt;loader&lt;/i&gt;代表了加载器的名字。&lt;/p&gt;

&lt;p&gt;安装完毕后，我们来写一些React代码。&lt;/p&gt;

&lt;h3 id=&quot;hello-react&quot;&gt;Hello React&lt;/h3&gt;

&lt;p&gt;首先安装react和react-dom&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i react react-dom -S
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用如下内容替换 &lt;i&gt;index.js&lt;/i&gt;中的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;

class App extends React.Component {
    render() {
        return &amp;lt;p&amp;gt; Hello React! &amp;lt;/p&amp;gt;;
    }
}

render(&amp;lt;App /&amp;gt;, document.getElementById(&#39;app&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后执行如下指令来更新打包文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack -d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后到浏览器中，你可以看到 &lt;i&gt;Hello React&lt;/i&gt;。&lt;/p&gt;

&lt;h3 id=&quot;webpack-1&quot;&gt;便捷化使用webpack&lt;/h3&gt;

&lt;h4 id=&quot;webpack-2&quot;&gt;通过webpack监控变化&lt;/h4&gt;

&lt;p&gt;当你每次改变文件时执行webpack指令不是一个高效的工作方式。我们可以执行如下指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack -d --watch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样webpack就以监控模式运行，无论检测到什么变化，它会重新自动打包文件。&lt;/p&gt;

&lt;p&gt;如果你不喜欢刷新浏览器，那你可以使用&lt;a href=&quot;http://gaearon.github.io/react-hot-loader/getstarted/&quot;&gt;react-hot-loader&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;npm&quot;&gt;使用npm作为执行工具&lt;/h4&gt;

&lt;p&gt;你可以使用npm来执行webpack的指令，更新&lt;code class=&quot;highlighter-rouge&quot;&gt;packages.json&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;dev&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;webpack -d --watch&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;webpack -p&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后在终端执行&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run build&lt;/code&gt;就可以执行webpack的生产模式，它可以自动压缩打包文件，而&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run dev&lt;/code&gt;则通过监控模式运行webpack&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;做一个小项目&lt;/h4&gt;

&lt;p&gt;接下来我们来做一个小的React项目，一个监控移动端手势控制图片大小、旋转角度的app。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.yumingyuan.me/gestures/index.html&quot;&gt;View Demo&lt;/a&gt;(请用移动端打开哦~)&lt;/p&gt;

&lt;p&gt;项目源码&lt;a href=&quot;https://github.com/ymyqwe/gestures&quot;&gt;在此&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该项目fork自&lt;a href=&quot;https://github.com/eeandrew/gestures&quot;&gt;eeandrew/gestures&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 06 Feb 2017 00:00:00 +0800</pubDate>
        <link>/2017/02/06/Getting-Started-With-Reactjs-Using-Npm-Webpack.html</link>
        <guid isPermaLink="true">/2017/02/06/Getting-Started-With-Reactjs-Using-Npm-Webpack.html</guid>
        
        <category>前端</category>
        
        <category>技术</category>
        
        <category>React</category>
        
        <category>Webpack</category>
        
        
      </item>
    
      <item>
        <title>React Tornado的配合使用</title>
        <description>&lt;p&gt;最近准备把公司的项目使用react来开发，由于公司的服务端使用的是tornado，因此在开发过程中也遇到了一些困难，因此将开发中遇到的一些问题记下来。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;目录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#babel&quot;&gt;Babel配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tornado&quot;&gt;Tornado数据处理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#react&quot;&gt;React组件开发&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;babel&quot;&gt;Babel配置&lt;/h2&gt;

&lt;p&gt;虽然目前大多数浏览器已经支持了&lt;a href=&quot;http://es6-features.org/#Constants&quot;&gt;ES6&lt;/a&gt;，但是仍然避免不了有一些特性无法在现代浏览器中使用。&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;是JavaScript语法转换器，可以将ES6代码转换成浏览器支持的代码。&lt;/p&gt;

&lt;p&gt;学习babel可以通过其手册&lt;a href=&quot;https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/README.md&quot;&gt;Babel handbook&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;babel-cli&quot;&gt;安装babel-cli&lt;/h3&gt;

&lt;p&gt;假设node和npm已经安装好，输入如下代码安装babel&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install -g babel-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完成后就可以编译文件了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ babel index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要输出到指定文件，可输入如下指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ babel index.js --output-file compiled.js
//或者
$ babel index.js -o compiled.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者可以修改整个目录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ babel src -d lib
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;npmbabel-cli&quot;&gt;使用npm配置babel-cli&lt;/h3&gt;

&lt;p&gt;首先初始化项目&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再安装babel&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save-dev babel-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中添加scripts命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;babel src -d lib&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，这时候还不能编译，因为还没有配置&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;文件，在项目的根目录下创建.babelrc文件。为了让babel将ES6转为ES5，安装如下依赖&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save-dev babel-preset-es2015
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完成后，创建&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;文件，添加如下参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;presets&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;es2015&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时我们就安装完所有的配置了，在终端中输入命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm run build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后即可编译ES6版本的React啦。&lt;/p&gt;

&lt;h2 id=&quot;tornado&quot;&gt;Tornado数据处理&lt;/h2&gt;

&lt;p&gt;一般来说，Tornado的数据是通过render_string方法，但是render_string会将函数的参数全部转为字符串，假如我们得到的数据是new_list，则在html的js中，需要如下所写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var new_list = { % raw new_list % }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们得到的数据就是对象或者数组格式的，可以直接在react中操作。&lt;/p&gt;

&lt;p&gt;如果数据是调用get或post接口返回的数据，则要求在接口输出数据的时候格式为json，假设调用接口返回的是send_line函数，则需要如下写接口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def send_line(self, response={}):
    self.set_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)
    data = json.dumps(response)
    self.finish(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后将数据通过&lt;code class=&quot;highlighter-rouge&quot;&gt;send_line&lt;/code&gt;返回即可.&lt;/p&gt;

&lt;h2 id=&quot;react&quot;&gt;React组件开发&lt;/h2&gt;

&lt;h3 id=&quot;getinitialstate&quot;&gt;getInitialState&lt;/h3&gt;

&lt;p&gt;该方法用于初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;this.state&lt;/code&gt;的值，只在组件装在前调用一次。如果使用ES6语法，使用该方法会报错，需要在构造函数中初始化状态，比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class App extends Component {
    constructor(props) {
        super(props);
        this.state = { data: new_list }
    }
    render() {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;生命周期函数&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;装载组件触发&lt;/h4&gt;

&lt;h5 id=&quot;componentwillmount&quot;&gt;componentWillMount&lt;/h5&gt;

&lt;p&gt;只会在装载之前调用一次，在&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;之前调用，可以在这个方法里调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setState&lt;/code&gt;改变状态，并且不会导致额外调用一次&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;componentdidmount&quot;&gt;componentDidMount&lt;/h5&gt;

&lt;p&gt;只会在装载完成之后调用一次，在&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;之后调用，从这里开始可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ReactDOM.findDOMNode(this)&lt;/code&gt;获取到组件的DOM节点。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;更新组件触发&lt;/h4&gt;

&lt;p&gt;这些方法不会再首次&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;组件的周期调用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;componentWillReceiveProps&lt;/li&gt;
  &lt;li&gt;shouldComponentUpdate&lt;/li&gt;
  &lt;li&gt;componentWillUpdate&lt;/li&gt;
  &lt;li&gt;componentDidUpdate&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;卸载组件触发&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;componentWillUnmount&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;循环插入子元素&lt;/h3&gt;

&lt;p&gt;如果组件中包含通过循环插入的子元素，为了保证重新渲染UI的时候能够正确显示这些子元素，每个元素都需要通过一个特定的key属性指定一个唯一值。具体原因是因为
Diff的效率，具体原因可以参考&lt;a href=&quot;https://facebook.github.io/react/docs/reconciliation.html&quot;&gt;React官方文档&lt;/a&gt;，由于mongoDB的所有数据都有一个特定的id，因此正好可以使用，看下面的例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Posts extends React.Component {
    render() {
        const onePost = this.props.data.map(function(post) {
            return (
                &amp;lt;Post key={post[&#39;_id&#39;]}/&amp;gt;
                )
        });
        return (
            &amp;lt;div&amp;gt;
                {onePost}
            &amp;lt;/div&amp;gt;
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;组件间的通信&lt;/h3&gt;

&lt;p&gt;一般来说，父子间的组件是易于维护的模式，所以一般将组件封装到大的组件里，而父子组件间的通信则比较容易，比如在父组件给子组件设置props，然后子组件就可以通过props访问到父组件的数据及方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Refresh extends React.Component {
    constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this)
    }
    handleClick() {
        this.props.handleRefresh()
    }
    render() {
        return(
            &amp;lt;div className=&quot;refresh&quot; onClick={this.handleClick}&amp;gt;
            &amp;lt;/div&amp;gt;
            )
    }
}

class Container extends React.Component {
    constructor(props) {
        super(props)
        this.handleRefresh = this.handleRefresh.bind(this);
        this.state = {data: new_list}
    }
    componentWillReceiveProps(nextProps) {
        this.handleRefresh(nextProps)
    }
    handleRefresh(props) {
        $.ajax({
            url:&#39;your-url&#39;,
            type: &#39;GET&#39;,
        })
        .done(function(res) {
            this.setState({data: res})
        }.bind(this))
    }
    render() {
        return (
            &amp;lt;div className=&quot;bg&quot;&amp;gt;
                &amp;lt;Postlist data={this.state.data}/&amp;gt;
                &amp;lt;BottomButton /&amp;gt;
                &amp;lt;Refresh handleRefresh={this.handleRefresh}/&amp;gt;
            &amp;lt;/div&amp;gt;
            )
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码显示了在一开始加载初始数据，如果点击刷新按钮(Refresh)，则会通过ajax加载新的数据，并且刷新父组件(Container)的数据，并且传输给子组件(Postlist)&lt;/p&gt;

&lt;p&gt;现在就来开始全面拥抱React吧！&lt;/p&gt;

</description>
        <pubDate>Mon, 09 Jan 2017 00:00:00 +0800</pubDate>
        <link>/2017/01/09/Problems-with-React-and-Tornado-develope.html</link>
        <guid isPermaLink="true">/2017/01/09/Problems-with-React-and-Tornado-develope.html</guid>
        
        <category>前端</category>
        
        <category>技术</category>
        
        <category>React</category>
        
        
      </item>
    
      <item>
        <title>使用Compass开发移动页面</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;安装Compass&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;Compass配置文件注意事项&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;Compass开发移动页面&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装&lt;/h2&gt;

&lt;h3 id=&quot;ruby&quot;&gt;安装Ruby&lt;/h3&gt;

&lt;p&gt;安装Ruby就不在这边赘述了，请参考官方文档：&lt;a href=&quot;https://www.ruby-lang.org/zh_cn/documentation/installation/&quot;&gt;安装Ruby&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;compass&quot;&gt;安装Compass&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem update --system
$ gem install compass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;compass-1&quot;&gt;创建Compass项目&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ compass create &amp;lt;myproject&amp;gt;
$ cd myproject
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：&lt;i&gt;$是终端的占位符，你不需要输入它。&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;就会生成如下的目录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--sass
--css
--images
--config.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中config.rb就是项目的配置文件，配置文件中包含。&lt;/p&gt;

&lt;h3 id=&quot;compass-2&quot;&gt;编译compass项目&lt;/h3&gt;

&lt;p&gt;compass的编译命令为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ compass compile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行该命令后，sass目录下的scss文件会被编译成css文件，保存到配置文件中的css目录。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;配置文件注意事项&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;配置文件注释问题&lt;/h3&gt;

&lt;p&gt;一般来说，编译后的css文件是默认有注释的，可以在配置文件中添加如下内容来取消注释&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;line_comments = false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的话就能取消注释，大大缩小css文件的大小。&lt;/p&gt;

&lt;h3 id=&quot;compass-3&quot;&gt;compass无法编译中文&lt;/h3&gt;

&lt;p&gt;开发的时候可能会用到中文注释、或者字体名称，但是compass默认是无法编译中文的，因此要在配置文件中加入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Encoding.default_external = &#39;utf-8&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同时，在你的scss文件加入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@charset &#39;utf-8&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样compass就可以编译中文了。&lt;/p&gt;

&lt;h3 id=&quot;css&quot;&gt;生产环境自动压缩css文件&lt;/h3&gt;

&lt;p&gt;默认编译的css文件是不压缩的，但是我们发布的时候为了节省资源，css文件都需要压缩，可以在配置文件中加入如下内容&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;output_stlye = :compressed
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者在编译的时候加上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;compass compile --output_stlye compressed
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;开发移动页面&lt;/h2&gt;

&lt;h3 id=&quot;rem&quot;&gt;使用rem适配移动端&lt;/h3&gt;

&lt;p&gt;Amfe阿里无线前端团队双11技术连载分享中提到了&lt;a href=&quot;https://github.com/amfe/article/issues/17&quot;&gt;手淘H5页面是如何实现多终端匹配&lt;/a&gt;，本文主要是在他们的基础上进行。&lt;/p&gt;

&lt;p&gt;rem的原理是根据html根元素的font-size值对元素进行大小设置，一般的根元素即为&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;，比如在根元素设定font-size = 75px，
那么1rem的代表的长度为1 * 75px。&lt;/p&gt;

&lt;h3 id=&quot;compasspxrem&quot;&gt;使用Compass转换px，rem&lt;/h3&gt;

&lt;p&gt;由于rem是写在css里面的，但是设计稿一般给的是px，所以需要将px转化为rem，如果你使用的是sublime text，有一个&lt;a href=&quot;https://github.com/flashlizi/cssrem&quot;&gt;cssrem&lt;/a&gt;插件可以供你使用，但是仍然需要每次输入px再按键转化为rem。&lt;/p&gt;

&lt;p&gt;使用Compass我们可以利用函数来转化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$originWidth: 750px;
//设计稿的宽度
@function pxToRem($px) {
    @return 10*$px/$ClientWidth/1*1rem;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再按如下方式使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div {
    width: pxToRem(750px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就得到一个宽度为10rem(整个屏幕)的div了。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;高清屏下面字体大小设置&lt;/h3&gt;

&lt;p&gt;设备像素比简称为dpr，定义了物理像素和设备独立响度的关系。它的值可以按下面的公式计算得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;设备像素比 = 物理像素 / 设备独立像素
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看下图可以明确解释dpr&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/dpr.jpg&quot; alt=&quot;&quot; style=&quot;margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;众所周知，iPhone6的设备宽度和高度为375pt * 667pt,可以理解为设备的独立像素；而其dpr为2，根据上面公式，我们可以很轻松得知其物理像素为750pt * 1334pt。&lt;/p&gt;

&lt;p&gt;屏幕增大之后，页面元素也会随之增大，但是有些比如段落文字的内容我们并不想增大，这时候不适合用rem作为字体单位，我们还是使用px，可以用如下@mixin来解决：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@mixin font-dpr ($font-size) {
    font-size: $font-size;
    [data-dpr=&quot;2&quot;] &amp;amp; {
        font-size: $font-size * 2;
    }
    [data-dpr=&quot;3&quot;] &amp;amp; {
        font-size: $font-size * 3;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样基本就可以解决移动端大部分的适配问题了。&lt;/p&gt;

&lt;p&gt;如有问题，欢迎联系~&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Jan 2017 00:00:00 +0800</pubDate>
        <link>/2017/01/08/Compass-develope-guide.html</link>
        <guid isPermaLink="true">/2017/01/08/Compass-develope-guide.html</guid>
        
        <category>前端</category>
        
        <category>技术</category>
        
        <category>HTML5</category>
        
        <category>SASS</category>
        
        
      </item>
    
      <item>
        <title>Python中文ASCII编码问题</title>
        <description>&lt;p&gt;最近在研究网页使用微信登陆拉取用户信息，而我使用的是tornado框架，拉取信息成功后，在网页前端输出的是正常的中文字符，但是在后台使用python print却是”\xe8\xe6”这样的字符，一查之后发现是控制台输出窗口按照&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt;编码输出了&lt;code class=&quot;highlighter-rouge&quot;&gt;utf8&lt;/code&gt;编码字符串的结果。&lt;/p&gt;

&lt;p&gt;如果想在控制台检查输出的结果，只要将要输出的信息添加上以上代码就可以了！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abc.decode(&#39;utf-8&#39;)
#abc为你获取到的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;怎么样，是不是很简单，快去控制台看一看吧~&lt;/p&gt;
</description>
        <pubDate>Mon, 23 May 2016 00:00:00 +0800</pubDate>
        <link>/2016/05/23/Python-Chinese-Encoding.html</link>
        <guid isPermaLink="true">/2016/05/23/Python-Chinese-Encoding.html</guid>
        
        <category>技术</category>
        
        <category>Python</category>
        
        
      </item>
    
      <item>
        <title>监控屏幕触摸事件</title>
        <description>&lt;p&gt;最近在开发一个新的移动端HTML5小游戏，用到了canvas，于是接触到了touch事件，对于获取触摸位置进行了一些研究，尝试了使用jquery的bind事件来感知屏幕触摸（但是jquery并不适合移动开发，请大家不要效仿，可以使用zepto或者jquery mobile），代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var canvas = $(&quot;#canvas&quot;);
var context = canvas[0].getContext(&quot;2d&quot;);
//$(&quot;#canvas&quot;)[0] equals to document.getElementById(&quot;canvas&quot;)
var inter;  //循环变量
var e;   //鼠标事件全局变量

canvas.bind(&#39;touchstart&#39;, function(eve) {
    e = eve;
    inter = setInterval(function() {
        interFun(e);
    }, 50)
})
   	
canvas.bind(&#39;touchmove&#39;, function(eve) {
    e = eve;
})

canvas.bind(&#39;touchend&#39;, function(eve) {
    console.log(e.originalEvent.touches.length);
    clearInterval(inter);
})

//循环函数
function interFun(e) {
    console.log(e);
    var touch = e.originalEvent.targetTouches[0];
    // jQuery event so we use originalEvent
    var mouseX = touch.pageX + document.body.scrollLeft - document.body.clientLeft - canvas[0].offsetLeft;
    var mouseY = touch.pageY + document.body.scrollTop  - document.body.clientTop - canvas[0].offsetTop;
    console.log(mouseX);
    console.log(mouseY);
    context.beginPath();
    drawStar(context, mouseX, mouseY);
    context.closePath();
    context.fill();
    context.stroke();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中使用到了jquery包装的事件，因此我们使用了originalEvent，此处的originalEvent即为TouchEvent，可以参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent&quot;&gt;MDN TouchEvent&lt;/a&gt;的文档&lt;/p&gt;

&lt;h4 id=&quot;targettouchestouchstart&quot;&gt;targetTouches代表一个仍与屏幕有接触的对象，它与touchstart事件触发的元素是相同元素。&lt;/h4&gt;
&lt;p&gt;#### touches代表所有与屏幕有接触的触摸对象，无论目标元素或者状态有无变化。&lt;/p&gt;

&lt;p&gt;同样，我们也可以使用addEventListener方法来监控各种触摸事件，代码如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var canvas = document.getElementById(&quot;canvas&quot;);
var context = canvas.getContext(&quot;2d&quot;);
//$(&quot;#canvas&quot;)[0] equals to document.getElementById(&quot;canvas&quot;)
var inter;  //循环变量
var e;   //鼠标事件全局变量

canvas.addEventListener(&quot;touchstart&quot;, TouchStart);
canvas.addEventListener(&quot;touchmove&quot;, TouchMove);
canvas.addEventListener(&quot;touchend&quot;, TouchEnd);

function TouchStart(eve) {
    e = eve;
    inter = setInterval(function() {
        interFun(e);
    }, 50)
}
function TouchMove(eve) {
    e = eve;
}
function TouchEnd(eve) {
    e = eve;
    clearInterval(inter);
}

function interFun(e) {
    console.log(e);
    var touch = e.originalEvent.touches[0];
    var mouseX = touch.pageX + document.body.scrollLeft - document.body.clientLeft - canvas.offsetLeft;
    var mouseY = touch.pageY + document.body.scrollTop  - document.body.clientTop - canvas.offsetTop;
    console.log(mouseX);
    console.log(mouseY);
    context.beginPath();
    drawStar(context, mouseX, mouseY);
    context.closePath();
    context.fill();
    context.stroke();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 05 May 2016 00:00:00 +0800</pubDate>
        <link>/2016/05/05/Events-about-Click-and-touch.html</link>
        <guid isPermaLink="true">/2016/05/05/Events-about-Click-and-touch.html</guid>
        
        <category>前端</category>
        
        <category>技术</category>
        
        <category>HTML5</category>
        
        
      </item>
    
      <item>
        <title>Ruby RVM is not working with ZSH</title>
        <description>&lt;h2 id=&quot;zshruby-gem&quot;&gt;安装ZSH后RUBY GEM无法工作&lt;/h2&gt;

&lt;p&gt;最近到了新公司，有人介绍给了我ZSH这个插件来美化Terminal，但是安装了ZSH之后，我用Jekyll搭建的博客在本地就无法运行了，在本地没办法调试的话，每次都要上传服务器调试，会特别麻烦。terminal报错显示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Users/maniauuuuu/.rvm/rubies/ruby-2.2.3/lib/ruby/site_ruby/2.2.0/rubygems/dependency.rb:315:in `to_specs&#39;: 
Could not find &#39;jekyll&#39; (&amp;gt;= 0) among 11 total gem(s) (Gem::LoadError)
Checked in &#39;GEM_PATH=/Users/maniauuuuu/.gem/ruby/2.2.0:/Users/maniauuuuu/.rvm/rubies/ruby-2.2.3/lib/ruby/gems/2.2.0&#39;, execute `gem env` for more information
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实，每次打开Terminal都会显示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Warning: PATH set to RVM ruby but GEM_HOME and/or GEM_PATH not set, see:
https://github.com/rvm/rvm/issues/3212
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;他已经告诉你ruby RVM的路径设置了，但是GEM_HOME和GEM-PATH没有设置，你可以到&lt;a href=&quot;https://github.com/rvm/rvm/issues/3212&quot;&gt;https://github.com/rvm/rvm/issues/3212&lt;/a&gt;上去找解决方法，但是这个页面也没有给出直接的解决方法，@mpapis告诉你OMZ并没有设置路径，你可以重新设置RVM的默认路径，&lt;a href=&quot;https://rvm.io/rubies/default&quot;&gt;https://rvm.io/rubies/default&lt;/a&gt;有直接的解决方法：&lt;/p&gt;

&lt;h3 id=&quot;ruby&quot;&gt;使用特定版本的ruby：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm --default use 2.2.3
# 把2.1.1替换为你已经安装过的ruby版本

$ ruby -v
# ruby 2.2.3p173 (2015-08-18 revision 51636) [x86_64-darwin15]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ruby-1&quot;&gt;使用你的系统版本ruby：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm use system

$ ruby -v
# 会显示你的系统版本ruby
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ruby-2&quot;&gt;使用你设置的默认版本ruby&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm default

$ ruby -v
# 显示你的默认版本ruby
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ruby-3&quot;&gt;显示你现在设置的默认版本ruby&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm list

rvm rubies

ruby-2.2.1 [ x86_64 ]
=* ruby-2.2.3 [ x86_64 ]

# =&amp;gt; - current
# =* - current &amp;amp;&amp;amp; default
#  * - default
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我使用了设置默认版本ruby就搞定了，你可以自己挑选一个方法试试看啦~&lt;/p&gt;

&lt;p&gt;——————————————————————————————————&lt;/p&gt;

&lt;p&gt;5.25更新&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27784961/received-warning-message-path-set-to-rvm-after-updating-ruby-version-using-rvm/28080063&quot;&gt;新的解决办法戳我&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;希望大家自取~&lt;/p&gt;

</description>
        <pubDate>Sat, 23 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/23/RVM-NOT-WORKING-WITH-OH-MY-ZSH.html</link>
        <guid isPermaLink="true">/2016/04/23/RVM-NOT-WORKING-WITH-OH-MY-ZSH.html</guid>
        
        <category>RVM</category>
        
        <category>ZSH</category>
        
        
      </item>
    
      <item>
        <title>CSS3新增伪类</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;结构型伪类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;目标型伪类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;UI元素状态型伪类&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;结构型伪类&lt;/h2&gt;

&lt;h3 id=&quot;root&quot;&gt;:root&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:root {
	background-color: #fcfcfc;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;:root伪类指向页面的根元素，99%的情况下是html元素，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;html {
	background-color: #fcfcfc;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nth-childn&quot;&gt;:NTH-CHILD(N)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ul li:nth-child(odd)	{
	bakcground-color: #666;
	color: #fff;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些样式将被应用到奇数项的li元素中，如果你想让另外一行有其他的样式，可以这么写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;table tr:nth-child(even) { .... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:nth-child&lt;/code&gt;也可以更精确地指向某一个元素，你可以指向list中的第三个的元素，像这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-child(3) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;尽管&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;在一个数列中，注意它并不从0开始。第一个元素是&lt;code class=&quot;highlighter-rouge&quot;&gt;:nth-child(1)&lt;/code&gt;，第二个是&lt;code class=&quot;highlighter-rouge&quot;&gt;:nth-child(2)&lt;/code&gt;，并以此类推。&lt;/p&gt;

&lt;p&gt;我们也可以这样使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-child(2n) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;无(2 × 0)&lt;/li&gt;
  &lt;li&gt;第二个元素(2 × 1)&lt;/li&gt;
  &lt;li&gt;第四个元素(2 × 2)&lt;/li&gt;
  &lt;li&gt;第六个元素(2 × 3)&lt;/li&gt;
  &lt;li&gt;第八个元素(2 × 4)&lt;/li&gt;
  &lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面给出的例子和&lt;code class=&quot;highlighter-rouge&quot;&gt;nth-child(even)&lt;/code&gt;一样，那么我们来看看下面一个例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-child(5n) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;无(5 × 0)&lt;/li&gt;
  &lt;li&gt;第五个元素(5 × 1)&lt;/li&gt;
  &lt;li&gt;第十个元素(5 × 2)&lt;/li&gt;
  &lt;li&gt;第十五个元素(5 × 3)&lt;/li&gt;
  &lt;li&gt;第二十元素(5 × 4)&lt;/li&gt;
  &lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你使用更长的表格或列表，我们也可以像这样添加或者扣除数字：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-child(4n+1) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;第一个元素((4 × 0)-1)&lt;/li&gt;
  &lt;li&gt;第五个元素((4 × 1)-1)&lt;/li&gt;
  &lt;li&gt;第九个元素((4 × 2)-1)&lt;/li&gt;
  &lt;li&gt;第十三个元素((4 × 3)-1)&lt;/li&gt;
  &lt;li&gt;第十七元素((4 × 4)-1)&lt;/li&gt;
  &lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时，你也可以把&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;设置成负数，像这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-child(-n + x) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比如你想要设置列表中的前五个元素，你可以这么做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-child(-n + 5) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;第五个元素(-0 + 5)&lt;/li&gt;
  &lt;li&gt;第四个元素(-1 + 5)&lt;/li&gt;
  &lt;li&gt;第三个元素(-2 + 5)&lt;/li&gt;
  &lt;li&gt;第二个元素(-3 + 5)&lt;/li&gt;
  &lt;li&gt;第一个元素(-4 + 5)&lt;/li&gt;
  &lt;li&gt;无(-5 + 5)&lt;/li&gt;
  &lt;li&gt;无(-6 + 5)&lt;/li&gt;
  &lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nth-last-childn&quot;&gt;NTH-LAST-CHILD(N)&lt;/h3&gt;

&lt;p&gt;他操作起来就像&lt;code class=&quot;highlighter-rouge&quot;&gt;:nth-child()&lt;/code&gt;的反向，从最后一个往前数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-last-child(1) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码会选中列表中的最后一个元素，你也可以使用其他规则创建：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:nth-last-child(2n+1) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nth-of-typen&quot;&gt;NTH-OF-TYPE(N)&lt;/h3&gt;

&lt;p&gt;现在我们将对更精确种类的元素添加样式，比如，你想给文章中第一段一个更大的字体，你可以这么做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;article p:nth-of-type(1) { font-size: 1.5em; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;又或者，你想让文章每隔一张图靠右，而另一张靠左，我们可以像下面这么做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;article img:nth-of-type(odd) { float: right; }
article img:nth-of-type(even) { float:left; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Simon Foster创建了一个特别的&lt;a href=&quot;http://www.fortherecord.simonfosterdesign.com/&quot;&gt;信息图像表&lt;/a&gt;，他采用了如下的样式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ul#genre li:nth-of-type(1) {
  width:32.9%;
  background:url(images/orangenoise.jpg);
}
ul#genre li:nth-of-type(2) {
  width:15.2%;
  background:url(images/bluenoise.jpg);
}
ul#genre li:nth-of-type(3) {
  width:13.1%;
  background:url(images/greennoise.jpg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nth-last-of-typen&quot;&gt;:NTH-LAST-OF-TYPE(N)&lt;/h3&gt;

&lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;nth-last-child&lt;/code&gt;类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;:nth-last-of-type()&lt;/code&gt;从被选中的元素的末尾开始，向前计数。&lt;/p&gt;

&lt;h3 id=&quot;first-of-typelast-of-type&quot;&gt;:FIRST-OF-TYPE与:LAST-OF-TYPE&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;:nth-of-type()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;:nth-last-of-type&lt;/code&gt;对你来说太精确了，你可以一些简化的选择器，比如，我们可以用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;article p:first-of-type { font-size: 1.5em }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;only-of-type&quot;&gt;ONLY-OF-TYPE&lt;/h3&gt;

&lt;p&gt;还有另外一种&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;选择器：&lt;code class=&quot;highlighter-rouge&quot;&gt;:only-of-type()&lt;/code&gt;。这对于选择某种父元素的唯一类型子元素来说很有用，&lt;/p&gt;

&lt;p&gt;比如，你可以思考一下这两个选择器之间的区别：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p { font-size: 18px; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p:only-of-type {font-size: 18px; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一个选择器会选中页面中所有的p元素，而第二种会获取页面中只是它父元素中的唯一段落。&lt;/p&gt;

&lt;h3 id=&quot;last-child&quot;&gt;:LAST-CHILD&lt;/h3&gt;

&lt;p&gt;CSS2中包含了&lt;code class=&quot;highlighter-rouge&quot;&gt;:first-child&lt;/code&gt;特性，但是直到CSS3才出现&lt;code class=&quot;highlighter-rouge&quot;&gt;:last-child&lt;/code&gt;的确让人觉得奇怪，它仅仅选择了它父元素的最后一个子元素而已，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li  {
	border-bottom: 1px solid #ccc
}

li:last-child  {
	border-bottom: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这对于移除列表的底部边框很有效，你经常可以在WordPress小工具中看到他。&lt;/p&gt;

&lt;h3 id=&quot;only-child&quot;&gt;:ONLY-CHILD&lt;/h3&gt;

&lt;p&gt;如果某个元素只有一个子元素，你可以这么选择它：&lt;code class=&quot;highlighter-rouge&quot;&gt;only-child&lt;/code&gt;。与&lt;code class=&quot;highlighter-rouge&quot;&gt;only-of-type&lt;/code&gt;不同，无论这是什么种类的元素，你都可以选择他，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li:only-child { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;empty&quot;&gt;:EMPTY&lt;/h3&gt;

&lt;p&gt;最后的结构型伪类是&lt;code class=&quot;highlighter-rouge&quot;&gt;:empty&lt;/code&gt;，他选择的是没有内容，没有子元素的元素，他在处理不同数据库输出的动态内容是有用的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#results:empty {
	background-color: #fcc; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可以在一个空的搜索框上使用这样的代码来吸引用户的注意。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;目标型伪类&lt;/h2&gt;

&lt;h3 id=&quot;target&quot;&gt;:TARGET&lt;/h3&gt;

&lt;p&gt;这个伪类允许我们选择基于URL的元素，如果这个元素有一个识别器（比如跟着一个#），那么&lt;code class=&quot;highlighter-rouge&quot;&gt;:target&lt;/code&gt;伪类会对使用这个ID识别器的元素增加样式。看下面这个链接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.example.com/css3-pseudo-selectors#summary
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个有&lt;code class=&quot;highlighter-rouge&quot;&gt;summary&lt;/code&gt;id的版块会被如下的样式渲染：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:target {
	background-color: #fcc;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这对于页面上的从外部内容链接过来的元素是很有效的。你也可以用它来标记一些内部的锚点。&lt;/p&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI元素状态型伪类&lt;/h2&gt;

&lt;h3 id=&quot;enableddisabled&quot;&gt;:ENABLED和:DISABLED&lt;/h3&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;:checked&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:enabled&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;:disabled&lt;/code&gt;组成了三种UI元素状态型伪类。他们允许你根据他们的状态来对元素进行样式渲染，用户或开发者设计设置他们的状态来显示样式，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;input:enabled {
	background-color: #dfd;
}

input:disabled {
	background-color: #fdd;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这对于用户能不能填写内容来说有一个重要的反馈，你在Javascript控制的动态特性中经常可以看到他们。&lt;/p&gt;

&lt;h3 id=&quot;checked&quot;&gt;:CHECKED&lt;/h3&gt;

&lt;p&gt;第三个伪类是&lt;code class=&quot;highlighter-rouge&quot;&gt;:checked&lt;/code&gt;，它处理了一个确认盒的状态。它也是对于用户的一个重要反馈，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;input[type=radio]:checked {
	font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;否定伪类&lt;/h2&gt;

&lt;h3 id=&quot;not&quot;&gt;:NOT&lt;/h3&gt;

&lt;p&gt;他选择了除了你指定的那个之外的元素，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:not(footer) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它选择了页面上所有元素，除了页脚。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;一些思考&lt;/h2&gt;

&lt;p&gt;CSS3伪类选择器并不会占据样式表里大块大块的代码，他们是精确的，动态的，并且更可能添加页面的最后触碰，而不是设置一个整体的样式。可能你想要放弃一个列表的底部边框，或者在用户填表时给用户视觉反馈，&lt;strong&gt;这对于CSS3来说是完全可能的&lt;/strong&gt;，在他的用途变得主流时，我期望它成为网页设置及们的常用工具。&lt;/p&gt;

&lt;p&gt;如果你看到这些选择器的有趣的、精彩的用途，希望在下面的留言板中给我留言！&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/22/Using-CSS3-Psuedo-classes.html</link>
        <guid isPermaLink="true">/2016/04/22/Using-CSS3-Psuedo-classes.html</guid>
        
        <category>HTML</category>
        
        <category>技术</category>
        
        <category>CSS3</category>
        
        
      </item>
    
      <item>
        <title>前端问题小结</title>
        <description>&lt;h3 id=&quot;title&quot;&gt;微信修改网页title，如何保证分享结果？&lt;/h3&gt;

&lt;h4 id=&quot;js-sdk&quot;&gt;1.使用微信的JS-SDK&lt;/h4&gt;

&lt;h4 id=&quot;jstitle&quot;&gt;2.黑魔法：利用js修改微信title&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//需要jQuery
var $body = $(&#39;body&#39;);
document.title = &#39;title&#39;;
// hack在微信等webview中无法修改document.title的情况
var $iframe = $(&#39;&amp;lt;iframe src=&quot;/favicon.ico&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&#39;);
$iframe.on(&#39;load&#39;,function() {
	setTimeout(function() {
		$iframe.off(&#39;load&#39;).remove();
		}, 0);
	}).appendTo($body);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;Javascript中本地对象、内置对象和宿主对象&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;本地对象，就是那些官方定义好了的对象。内置对象是本地对象的一种，其只包含Global对象和Math对象。而宿主对象则是那些官方未定义，你自己构建的对象加上DOM和BOM对象组成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;如何优化页面加载速度&lt;/h3&gt;

&lt;p&gt;减少 HTTP 访问次数、CDN、minify、服务器增加缓存、CSS 放前面 JS 放后面、图片压缩、CSS Sprite。&lt;/p&gt;

&lt;h3 id=&quot;javascript-1&quot;&gt;读过那些Javascript的书？&lt;/h3&gt;

&lt;p&gt;《JavaScript高级程序设计》、《Javascript权威指南》、《Good parts of Javascript》&lt;/p&gt;

&lt;h3 id=&quot;ajax&quot;&gt;AJAX获取数据的两个方式及他们的区别？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务器。当然在Ajax请求中，这种区别对用户是不可见的。&lt;/li&gt;
  &lt;li&gt;GET方式对传输的数据大小有限制，通常不能大于2KB,而POST方式传递的数据量要比GET方式大得多，理论上不受限制。&lt;/li&gt;
  &lt;li&gt;GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。&lt;/li&gt;
  &lt;li&gt;GET方式和POST方式传递的数据在服务器端的获取也不相同。在PHP中，GET方式的数据可以用$_GET[]获取，而POST方式可以用$_POST[]获取。两种方式都可以用$_REQUEST[]来获取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bootstrap-23&quot;&gt;BOOTSTRAP 2、3的区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;3以移动优先；&lt;/li&gt;
  &lt;li&gt;3以扁平化为特点，2则偏向凹凸化；&lt;/li&gt;
  &lt;li&gt;3兼容性更高，如果你选择兼容IE8或6、7，那么就选择2。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/17/Some-Thinking-About-Myself.html</link>
        <guid isPermaLink="true">/2016/03/17/Some-Thinking-About-Myself.html</guid>
        
        <category>前端</category>
        
        <category>技术</category>
        
        <category>翻译</category>
        
        
      </item>
    
      <item>
        <title>ANGULAR VS. EMBER VS. REACT: 选择一个前端框架</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;目录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#angular-20&quot;&gt;ANGULAR&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ember-20&quot;&gt;EMBER&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#react-10&quot;&gt;REACT&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;作为前端工程师，我们活在一个令人兴奋的时代。最大的三个框架都接近或已经有重大的更新。Ember不久前发布了可以轻易从老版本更新的2.0版本。React发布了0.14，而Angular 2.x也即将要大放异彩。&lt;/p&gt;

&lt;p&gt;当然，现在还有许多其他客户端框架，也有一些在诸如Backbone和Knockout之类的正在衰败的库，也有一些新奇的、有趣的像Aurelia一样的新晋者，但是如今你决定要做一个web app， Angular、Ember、React是确保长效支持和活跃社区的最安全的选择。那么哪一个选择是最优的呢？让我们来分析下这些新的重要的更新带来的改变以及他们提供的优势。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/angular2.png&quot; alt=&quot;&quot; style=&quot;margin:auto&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;angular-20&quot;&gt;ANGULAR 2.0&lt;/h2&gt;

&lt;p&gt;Angular是三个框架中最流行的。它是最早发布的MVC客户端框架，代表了客户端MVC框架从前一代的巨大提升。Angular走了一条务实的途径，与用户之间产生了共鸣。&lt;/p&gt;

&lt;p&gt;但是这些都被Angular 2.0的出现危害了，Angular 2.0有点失败。不同于Ember，Angular的第二版本完全重建了这个框架。这意味着对每一段代码会产生巨大的变化。这意味着从1.x版本重构代码会很难，同时从老版本升级的路径会很难。&lt;/p&gt;

&lt;p&gt;但是一个奇迹诞生了，Angular团队发明了允许项目同时使用Angular 1.x和2.0的方法，使版本更迭成为了一个渐进的过程。在我看来，这将Angular从特定的阻塞、对于挑战的恐惧和遗留的代码基础中解救出来。&lt;/p&gt;

&lt;p&gt;虽然已经避开了中途死亡，许多现在创造出来的项目仍然使用1.x版本，准备在1.x被淘汰之后，计划逐渐接纳2.0版本。如果你愿意承担巨大的风险，并且不准备立即发布，尽管去使用新版本吧。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;在2.0版本中你应该期待什么？&lt;/h3&gt;

&lt;p&gt;你可以期待许多。这个框架到目前为止正在经历最大的版本变化。&lt;/p&gt;

&lt;p&gt;Angular 2.0的开发侧重于移除该框架的不必要的复杂性。他们去除并且取代了directives、controllers、modules、scopes和几乎所有其他的1.x版本的概念。它充分保留了ES2015和ES2016的特性，并且将这个框架设计成更容易学习。&lt;/p&gt;

&lt;p&gt;除了让框架更轻便，2.0版本还有一些其他的显著的目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;性能提升&lt;/li&gt;
  &lt;li&gt;原生app支持&lt;/li&gt;
  &lt;li&gt;服务器端渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些改变对于Angular来说是巨大的，使用1.x版本来构建他们会十分困难。我们来详细看看这些改变以及他们对于这个框架的意义。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;性能&lt;/h4&gt;

&lt;p&gt;提升性能是所有人希望的Angular的下一版本中的重要项目之一，如果你已经对Angular足够熟悉，那么你可以开始让一个app缓慢开启。总有一种方法是可以弥补性能问题的，但这个框架并不会让你避免搬石砸脚。&lt;/p&gt;

&lt;p&gt;Angular在脏检测中阻碍了自己的性能。在每个监测循环中，这个框架检测了你的app中成百上千个值的改变。Angular的新模型接受了React推广的一个实践，单向数据传输和不可变的数据。通过接受这些，Angular现在只在数据改变之后更新。检测改变只会快速检测一个对象而不是所有变量。&lt;/p&gt;

&lt;h4 id=&quot;app&quot;&gt;原生app&lt;/h4&gt;

&lt;p&gt;使用Angular创建原生app对于2.0来说是它发展历程上一个重要的提升。Angular团队和React团队曾经对于这个问题进行过讨论。尽管他们构建2.0的原生app时背后的渲染仍然使用React的原生渲染，允许他肩负了这项技术。这将引领一个混合app的新时代，它看起来像是原生的，但是却有跨平台的共通逻辑。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;服务器端渲染&lt;/h4&gt;

&lt;p&gt;Angular在服务器端的渲染是另一项被期待的功能。服务器端渲染加速了原始页面的加载次数，并且通过使动态页面易于加载提升了SEO。看到页面渲染加速将很大提升下一代使用Angular构建的web app的体验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/angular2-str-weak.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;angular&quot;&gt;谁应该使用Angular？&lt;/h4&gt;

&lt;p&gt;Angular很可能会以很长时间作为最流行的客户端框架，这使得任何人开始一个新项目时它会成为一个安全的选择。2.0代表了Angular从最初版本的一个巨大的改变。事实上，这样巨大的改变就如同Ember与SproutCore有巨大差异一样。&lt;/p&gt;

&lt;p&gt;Angular 2.0是通过Typescript写的，这是一种微软添加了检查和其他增强的Javascript编程语言。事实上，最近关于它的社区中有一个民意投票，大部分开发者愿意使用Typescript。这以及一些其他的特性让我们有理由相信Angular仍将是大型企业愿意选择的框架。尽管如今开始使用2.0会有风险，但它的时代即将来临。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ember 2.0.png&quot; alt=&quot;&quot; style=&quot;margin:auto&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ember-20&quot;&gt;EMBER 2.0&lt;/h2&gt;

&lt;p&gt;Ember把它自己定位为一个为了具有前景的项目定制的框架。Ember在工业界中由两位传奇的软件工程师引领，Yehuda Katz和Tom Dale。与其他在这里被讨论的框架不同，Ember并非由一个特大企业构建，尽管它有一个令人惊奇的、富有激情的、活跃的社区围绕着它。&lt;/p&gt;

&lt;p&gt;在1.0版本之前，Ember由于它的多变的API变得繁荣。随后，Ember团队证明了可以在稍稍改变用户界面的情况下作出很大的潜在变化。他们采用了Glimmer这个高速渲染引擎。2.0版本他们移除了不能使用这个引擎的不利部分，因此使用Ember 2.x的app将会很快腾飞。&lt;/p&gt;

&lt;h3 id=&quot;x&quot;&gt;2.x版本将会带来什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;更加兼容诸如modules、classes、decorators之类的ES2015特性；&lt;/li&gt;
  &lt;li&gt;弃用Mustache，启用部件的支架语法；&lt;/li&gt;
  &lt;li&gt;布局结构变为pods，而非通过功能分组的controllers、models、components等等，顶部结构将是特性分类的；&lt;/li&gt;
  &lt;li&gt;由于路由部件，Controllers将被删除；&lt;/li&gt;
  &lt;li&gt;服务器端渲染器的提升将帮助降低页面加载次数并帮助提升搜索引擎优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/ember-2-str-weak.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ember&quot;&gt;谁应使用Ember？&lt;/h3&gt;

&lt;p&gt;Ember对于创建web app是一个方便的选择。如之前提到的一样，许多有雄心的app使用这个框架来搭建。特别是Ruby社区，对于Ruby商店来说，Ember是一个很棒的选择。许多文档、文章和博客都是通过这两种技术的结合来搭建的，&lt;a href=&quot;http://smashingboxes.com/blog/merging-rails-and-ember-cli&quot;&gt;这里是如何结合Rails和Ember的实例&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Ember对于那些那些包括所有工具的网站是一个最佳选择。我们通常会浪费很多时间在发现、搜索和整合类库上。Ember简化了这些流程，给你提供了惊人的价值。各种方法总有优势、劣势，但是那些希望所有东西都变得很好的人会喜欢Ember的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/React 1.0.png&quot; alt=&quot;&quot; style=&quot;margin:auto&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;react-10&quot;&gt;REACT 1.0&lt;/h2&gt;

&lt;p&gt;React是这里比较的三个框架中最轻的一个。实际上，它甚至不能被认为是一个框架。它做一件事做得特别好：渲染UI部件。许多人甚至会搭配使用之前提到的框架，但是更通常的方法是搭配使用Flux。&lt;/p&gt;

&lt;p&gt;Flux在MVC层面上是一种不同的方案。与React其他生态系统一样，它仍然是一个只控制一种东西的库。这种情况下，它从模型界面上的改变呈现为视图界面上的改变。它仍然不包括其他特定的框架，比如与服务器交互、验证模型或者是依赖注入。如果你需要这些功能，会有其他的库来弥补它们。&lt;/p&gt;

&lt;p&gt;Facebook为了保持它们页面的UI一致，创造了React。由于它在服务器端的渲染和优越的性能，它的出现引起了轩然大波。看到Angular和React在它们的新版本上不断竞争是很有趣的。&lt;/p&gt;

&lt;p&gt;React仍然在不断创新，最引人注意的是React Native。Facebook在移动端平台上有很快速的原生app。之前它们就开源了React Native的Andriod平台。这对于想要做原生app的人来说是一个不错的选择。&lt;/p&gt;

&lt;h3 id=&quot;react-10-1&quot;&gt;React 1.0的发布的主要目标是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;项目网站修改&lt;/li&gt;
  &lt;li&gt;文档改进&lt;/li&gt;
  &lt;li&gt;动画操作控制优化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/react-str-weak.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;react&quot;&gt;谁应使用React？&lt;/h3&gt;

&lt;p&gt;React对新和的已存的项目是很棒的选择。使用React分解你的UI并且重新构造它是很容易的。因此如果你要逐渐现代化现存的代码，React将是一个合适的选择。许多构建web app时的挑战性部分在React和Flux面前会变得琐碎。&lt;/p&gt;

&lt;p&gt;React在过去几年中成为了客户端MVC发展的领导力量，其他框架都成为了React可以做的事情的追赶者。React基本都是通过ES2015规范写成的，领先于许多浏览器支持。如果你想走在前端或利用简单框架，React是你的正确选择。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;三者相比&lt;/h3&gt;

&lt;p&gt;首先，这些框架看起来似乎在趋同。尽管他们有独特的特性，许多最佳的观点在三者中是一样的。比如单向数据流，另外，像XML一样的部件很快将在三者中存在。&lt;/p&gt;

&lt;p&gt;这些框架中，Ember是最容易上手的。只要你有一个网络服务器，就可以立即开展工作。而另外两个则需要你花点时间在Gulp和Webpack的配置上。你可能会在让项目布局上虚度光阴。或者可能花时间在拷贝样板项目上。而Ember则省去了所有这些问题。&lt;/p&gt;

&lt;p&gt;但是，对于我来说，Ember是最需要花时间来学习的。对于如此小一个项目来说，花这么多时间有点浪费。此外，Ember需要你通过特殊方式去做一些事情，并且脱离这些方法是困难的。对于Rails来说这两个劣势也是老生常谈。对我来说，这意味着Ember对于许多开发者来说，他有利于长期存在的项目。&lt;/p&gt;

&lt;p&gt;比较来说，另外两个框架对于我做的任何事情都似乎能扯上关系。Angular 2.0让我惊奇，它和1.x完全不同。但是我发现了一些实例后，用它来构建app也似乎变得简单。&lt;/p&gt;

&lt;p&gt;在最终版本中，Angular app的行数最少。但是用React写的时候很容易会这样想：『我应该把这一块逻辑拖出来独立』。这样增加了代码的行数但是将来做改变会变得容易。在Angular和Ember中，持续添加代码到模板、添加功能到部件很容易。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/wins.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;谁赢了？&lt;/h3&gt;

&lt;p&gt;我们很容易知晓为什么这三个框架如此流行。他们都有许多优势。因此，我建议多用用他们。他们之间并没有明显的胜者。在特定的情况下用特定的框架。即时没有别的，学习所有的三种框架会帮你写更好的代码。&lt;/p&gt;

&lt;p&gt;说了这么多，这三个框架都是很有未来的，这些框架的下一代会更加闪耀，并且支持服务器端渲染，Angular和React会支持iOS和Andriod的原生UI控件。通过这些控件，我们能比过去做更多的事。&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/15/CHOOSING-A-FRONT-END-FRAMEWORK-ANGULAR-VS-EMBER-VS-REACT.html</link>
        <guid isPermaLink="true">/2016/03/15/CHOOSING-A-FRONT-END-FRAMEWORK-ANGULAR-VS-EMBER-VS-REACT.html</guid>
        
        <category>前端</category>
        
        <category>技术</category>
        
        <category>翻译</category>
        
        
      </item>
    
      <item>
        <title>Front-End Development Notes</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;一些小笔记&lt;/h3&gt;

&lt;h3 id=&quot;section-1&quot;&gt;目录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;undefined is not a function &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;transition in safari and firefox is ignored in inline elements.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;Cannot read property ‘getElementsByTagName’ of null&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;ruby rails unable to load fontawesome &lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;undefined-is-not-a-function&quot;&gt;Undefined is not a function&lt;/h2&gt;
&lt;p&gt;Sometimes when you use $(document).ready(function() {})
An error occurs.
It is a collision of jQuery library.
TURN
  $(document).ready(function() { })
into
jQuery(function($)) {  }&lt;/p&gt;

&lt;h2 id=&quot;css3-transition-in-safari-and-firefox-is-ignored-in-inline-elements&quot;&gt;CSS3 transition in safari and firefox is ignored in inline elements.&lt;/h2&gt;
&lt;p&gt;Display it in block or inline-block element.&lt;/p&gt;

&lt;h2 id=&quot;cannot-read-property-getelementsbytagname-of-null&quot;&gt;Cannot read property ‘getElementsByTagName’ of null&lt;/h2&gt;
&lt;p&gt;Document.body won’t get a value assigned to it until the body element has been created.&lt;/p&gt;

&lt;h2 id=&quot;ruby-rails-unable-to-load-fontawesome&quot;&gt;ruby rails unable to load fontawesome&lt;/h2&gt;
&lt;p&gt;Ruby rails loads fontawesome path needs to add ‘config.assets.paths « Rails.root.join(‘app’,’assets’) ‘ to the application.rb.
Change  font-awesome.min.css to font awesome.min.css.scss.rb
Change the url in the fontawesomw.css.scss.erb to ‘&amp;lt;%= asset_path(“font/fontawesome-webfont.eot”) + “?v=3.2.1” %&amp;gt;’
Besides, you need to restart rails server.
&lt;!-- ##郁闷的感情历程 --&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 30 Jan 2016 00:00:00 +0800</pubDate>
        <link>/2016/01/30/Small-notes.html</link>
        <guid isPermaLink="true">/2016/01/30/Small-notes.html</guid>
        
        <category>技术</category>
        
        
      </item>
    
  </channel>
</rss>
